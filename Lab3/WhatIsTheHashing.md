## **1. ОТКРЫТОЕ ХЕШИРОВАНИЕ (Метод цепочек)**

### **Как устроено:**
Представь себе **шкаф с ящиками**. Каждый ящик — это "ведро" (bucket), а внутри ящика висят крючки с цепочками.

```
Словарь = массив из N "ведер" (buckets)
Каждое ведро → связанный список элементов

Индекс 0: [ ] → "John" → "Anna" → NULL
Индекс 1: [ ] → NULL
Индекс 2: [ ] → "Bob" → "Kate" → "Mike" → NULL
...
Индекс N-1: [ ] → "Sam" → NULL
```

### **Как работает:**
1. **Вставка (INSERT):**
   - Вычисляем хеш: `h = hash("имя") % N`
   - Идем в bucket с индексом `h`
   - Добавляем имя в конец цепочки (списка) этого bucket
   - Если имя уже есть — ничего не делаем (или обновляем)

2. **Поиск (MEMBER):**
   - Вычисляем хеш: `h = hash("имя") % N`
   - Идем в bucket `h`
   - Проходим по всей цепочке, сравнивая имена
   - Нашли → true, не нашли → false

3. **Удаление (DELETE):**
   - Находим элемент через поиск
   - Удаляем его из цепочки (как из обычного связного списка)

4. **Коллизии (совпадение хешей):**
   - Два разных имени попали в одно ведро
   - Решение: просто добавляем в цепочку
   - Пример: "Anna" (65+110+110+97=382) и "Bob" (66+111+98=275) могут иметь одинаковый хеш при N=10: 382%10=2, 275%10=5 (в данном случае разные, но если бы совпали — были бы в одной цепочке)

### **Особенности:**
- **Плюсы:** Просто реализовать, автоматически обрабатывает коллизии
- **Минусы:** Тратит память на указатели, медленнее из-за проходов по спискам
- **Загрузка:** Когда цепочки становятся длинными (>5-10 элементов), производительность падает

## **2. ЗАКРЫТОЕ ХЕШИРОВАНИЕ (Линейное пробирование)**

### **Как устроено:**
Представь себе **парковку с пронумерованными местами**. Если место занято — едешь дальше и ищешь первое свободное.

```
Словарь = массив из N слотов (ячеек)
Каждый слот либо пуст, либо содержит имя

Индекс 0: "John"
Индекс 1: "Anna"  (коллизия: хотела на 0, но он занят)
Индекс 2: пусто
Индекс 3: "Bob"
Индекс 4: "Kate"  (коллизия: хотела на 3, но он занят)
...
Индекс N-1: пусто
```

### **Как работает:**
1. **Вставка (INSERT):**
   - Вычисляем начальный хеш: `h0 = hash("имя") % N`
   - Если слот `h0` свободен → записываем имя туда
   - Если занят → пробуем `h1 = (h0 + 1) % N`
   - Если `h1` занят → `h2 = (h0 + 2) % N`
   - И так далее, пока не найдем свободный слот

2. **Поиск (MEMBER):**
   - Вычисляем `h0 = hash("имя") % N`
   - Смотрим слот `h0`:
     - Если пусто → false (имени нет)
     - Если совпало имя → true
     - Если имя другое → идем дальше: `h1`, `h2`, ...
   - Ищем пока:
     - Не найдем имя → true
     - Не найдем пустой слот → false (значит имени никогда не было)
     - Не пройдем все N слотов

3. **Удаление (DELETE):** — САМОЕ СЛОЖНОЕ!
   - Нельзя просто очистить слот (сломает поиск других элементов)
   - **Решение:** Ставим специальную метку "удалено" (не пусто, не занято)
   - При вставке: можно использовать слоты "удалено"
   - При поиске: пропускаем слоты "удалено", продолжаем искать

4. **Коллизии:** Решаются линейным пробированием (движемся вперед)

### **Особенности:**
- **Плюсы:** Нет указателей → экономия памяти, быстрее для коротких пробегов
- **Минусы:** Сложное удаление, кластеризация (элементы "сбиваются в кучки")
- **Загрузка:** Нельзя заполнять >70-80%, иначе поиск замедляется

## **3. ФУНКЦИЯ ХЕШИРОВАНИЯ**

Для обоих методов используется одинаковая:
```python
def hash(name):  # псевдокод
    sum = 0
    for char in name:
        sum = sum + ASCII_код(char)
    return sum % размер_массива
```

**Пример:**
```
Имя: "John" (J=74, o=111, h=104, n=110)
Сумма: 74+111+104+110 = 399
Размер массива: 10
Хеш: 399 % 10 = 9
```

## **4. АТД СЛОВАРЬ - ОПЕРАЦИИ**

### **MEMBER(D, x)** - "Есть ли законодатель в словаре?"
- **Вход:** Словарь D, имя x
- **Выход:** true/false
- **Логика:** Ищем имя в словаре по хешу

### **MAKENULL(D)** - "Очистить базу данных"
- **Вход:** Словарь D
- **Выход:** Пустой словарь
- **Логика:** Все элементы удалены/помечены как пустые

### **INSERT(D, x)** - "Добавить законодателя"
- **Вход:** Словарь D, имя x
- **Выход:** Словарь с добавленным x
- **Логика:** Если имени нет → добавляем, если есть → ничего (или обновляем)

### **DELETE(D, x)** - "Удалить законодателя"
- **Вход:** Словарь D, имя x
- **Выход:** Словарь без x
- **Логика:** Находим и удаляем имя

### **PRINT(D)** - "Показать всех законодателей"
- **Вход:** Словарь D
- **Выход:** Вывод на экран всех имен
- **Логика:** Проходим по всем элементам, выводим непустые

## **5. ПРИМЕНЕНИЕ К ТВОЕЙ ЗАДАЧЕ (ОЗТ)**

### **Структура программы:**
```
Два словаря: goodguys и badguys
Каждый словарь может быть реализован двумя способами
```

### **Обработка команд:**

#### **F "правильно"**
```
Имя попадает в goodguys (INSERT)
Имя удаляется из badguys (DELETE, если там было)
```

#### **U "неправильно"**
```
Имя попадает в badguys (INSERT)  
Имя удаляется из goodguys (DELETE, если там было)
```

#### **? "статус"**
```
if MEMBER(goodguys, имя):
    print("Good guy")
else if MEMBER(badguys, имя):
    print("Bad guy")
else:
    print("Не голосовал или неизвестен")
```

#### **P "вывод всех"**
```
print("Good guys:")
PRINT(goodguys)

print("\nBad guys:")  
PRINT(badguys)
```

#### **E "выход"**
```
Завершение программы
```

## **6. КЛЮЧЕВЫЕ МОМЕНТЫ РАЗРАБОТКИ**

### **Для открытого хеширования:**
1. Создай структуру `Node`: `{char[10] name, Node* next}`
2. Словарь = массив указателей на Node (размер N)
3. Каждый bucket = односвязный список
4. При коллизии → добавляешь в конец списка

### **Для закрытого хеширования:**
1. Словарь = массив структур `{char[10] name, int state}` 
   где state = 0(пусто)/1(занято)/2(удалено)
2. При коллизии → линейное пробирование: `(hash + i) % N`
3. Удаление → state = 2 (не 0!)

### **Общие рекомендации:**
1. **Выбери размер массива** (например, 101 — простое число, уменьшает коллизии)
2. **Обработай все случаи:**
   - Вставка когда нет места (увеличь массив или сообщи об ошибке)
   - Поиск несуществующего элемента
   - Удаление несуществующего элемента
3. **Тестируй на краевых случаях:**
   - Одинаковые имена
   - Очень длинные имена (обрезай до 10 символов)
   - Пустые имена
   - Все элементы удалены/добавлены

## **7. ПРИМЕР РАБОТЫ ПРОГРАММЫ**

```
Ввод:           База данных:
F John          goodguys: John
U Anna          badguys: Anna
? John          → Good guy
? Anna          → Bad guy  
? Bob           → Не голосовал
F Anna          goodguys: John, Anna
                badguys: (пусто)
U John          goodguys: Anna
                badguys: John
P               Вывод:
                Good: Anna
                Bad: John
E               Выход
```

## **8. ЧТО ПРОВЕРИТЬ ПРЕПОДАВАТЕЛЬ**

1. **Корректность хеширования** — одинаковые имена → одинаковый хеш
2. **Обработка коллизий** — что происходит при совпадении хешей
3. **Все операции АТД** — работают ли правильно
4. **Память** — нет утечек (особенно в открытом хешировании)
5. **Интерфейс** — соответствие заданию (команды F, U, ?, P, E)
6. **Два варианта** — оба метода хеширования реализованы